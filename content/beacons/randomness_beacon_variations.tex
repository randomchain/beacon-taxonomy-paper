\subsection{Randomness Beacon Variations}
%   Properties of beacons
 To understand different types of beacons, we define three categories, which can be used to describe properties that vary between different types of beacons.
These sets of properties cover \emph{entropy sourcing}, \emph{execution model}, and \emph{validation}, and will also be tied back to the security properties of beacons.
In the later taxonomy of current randomness beacons approaches, these properties will also be used for classification.

%       Entropy sourcing
\subsubsection{Entropy Sourcing}
The input of a randomness beacon at a given time, $I_t$, is the source the entropy of the outcome.
The following points describe different ways for a randomness beacon to source the input.
\begin{description}
    \item[User Input:]
        The protocol allows users to provide entropy.
        This can open up for direct manipulation of the result using last-draw attacks.
        If user input is the only source of entropy, lack of users prevent the beacon from operating, denying availability.

        There can also be too many inputs, resulting in input sourcing cutoff. Not all user inputs will be used in the computation of the outcome, thereby tarnishing those users' ability to trust the current output of the beacon.

    \item[Internal Input:]
        The beacon uses input such as background radiation or output from photon splitters, measured with some local device.
        These sources often provide high entropy, but are difficult if not impossible to reproduce and verify for users. Hence, complete trust in the honesty of the beacon operator is required.

    \item[External Input:]
        The beacon uses some publicly available data for input. For input to be considered publicly available, it must be accessible to the public and consistent over a period.
        These sources can for example be the bitcoin blockchain, financial data, or national lottery results.

        Anyone who wishes to manipulate the beacon's output must do so through the external source.
        For this type of source it is important to analyze the integrity of the source to understand the integrity of the randomness beacon itself.

        It is important to note that external input does not violate the unpredictability property of the beacon, since the time advantage an adversary has over regular users is negligible regardless of computing resources.
        Furthermore, any user of the beacon will be able to verify that the input has been used to generate the outcome.

\end{description}

%       Execution model
\subsubsection{Execution Model}
Once the input entropy is obtained, some computation is performed, $f(I_t)$, to extract near uniform randomness for the outcome.
We identify the following ways of executing such a computation in a randomness beacon protocol:

\begin{description}
    \item[Self-Announced Entity:]
        The protocol is computed by a central entity who provides a service in form of a beacon.
        This type of execution requires verifiability or complete trust in the central entity.

        The entity, while self-announced, can be driven by a community, authority, or single person, but is always controlled by that entity.
        Availability is a major concern with this type of execution, since it imposes a single point of failure, if not for computation then for trust.

    \item[Elected Operator:]
        A user is collectively elected to be the operator which performs the computation.
        That user then executes the beacon protocol as a public good.
        This type of execution participation requires that the operator has an incentive to carry out the beacon protocol, and may hurt availability if the operator is unable to complete.

    \item[Distributed Execution:]
        The computation of the protocol is done in a distributed manner between a set of parties e.g.\ using \gls{mpc} and/or smart contracts.
        This model potentially does not require trust in any other participant depending on the execution scheme.
        However, scalability to larger settings may prove difficult, and participants with byzantine behavior must be accounted for, which can hurt execution time and availability.

    \item[Self-Service Execution:]
        Each user performs the same execution to obtain a random value. The beacon is provided as a self-service function.
        This model does not require trust in the executing participants, only in the input entropy, and last-draw attacks and manipulation can become prevalent with potential predictability if using user input.
        Computational resources are only consumed by participants with a stake in the beacon output.
\end{description}

%       Validation
\subsubsection{Validation}
The output of the computation in the randomness beacon need some form of validation in order to be trustworthy.
We identify the following ways of validating a beacon:

\begin{description}
    \item[Verifiable:]
        A user can verify the randomness to have been correctly computed from the provided entropy.
        This is directly related to the verifiability in the earlier trust assumptions.

    \item[Contestable:]
        Users can contest the randomness of the beacon if they believe it to be wrong.
        The beacon operator must then prove the correctness or incur some penalty, while a user that successfully contests the beacon is rewarded. \mtjnote{This will be futher elaborated}
\end{description}

\subsubsection{Effects on Properties}
We evaluate each type of property based on their effect on the previously defined security properties for randomness beacons. We present this evaluation in a table of variations and their effects on properties. We use \emph{+} to indicate that a variation improves or supports a given property, and vice versa with \emph{-}. Each field also contains reasons for their score.

\newcommand{\good}[1]{$+$#1}
\newcommand{\baad}[1]{$-$#1}
\newcommand{\neut}[1]{$\pm$#1}

\begin{table}[htb]
    \centering
    \footnotesize
    \begin{tabularx}{\textwidth}{XXXXX}
        \toprule
                       & Unpredictability                                                 & Randomness                       & Availability                           & Verifiability                             \\ \midrule
User Input             & \baad{Needs many inputs}%{why? Two is enough}
                       & \baad{No guarantees on entropy}%{isn't it guaranteed to be as high as highest input}
                       & \baad{Requires user inputs}
                       & \good{Commit to inputs}%{what about verifying computation on the inputs}
\\
External Input         & \baad{Can predict negligible time before beacon}%{is this bad?}
                       & \neut{Source determines entropy}
                       & \baad{Depends on source availability}
                       & \good{Source is public}                   \\
Internal Input         & \good{Unavailable to adversaries}%{what if the beacon is an adversary!?}
                       & \good{Typically high entropy}%{how can that even be guaranteed?}
                       & \good{Stability and control of source}
                       & \baad{Requires proofs}%{And complete blind trust, since proofs say nothing}
\\
Self-announced entity  & N/A                                                              & N/A                              & \baad{Single point of failure}         & N/A                                       \\
Elected Operator       & N/A                                                              & N/A                              & \baad{Single point of failure}         & N/A                                       \\
Distributed Execution  & \baad{Participants may use intermediate information to predict}%{how? it requires all participants to get correct outcome, no?}
                       & N/A
                       & \baad{Can fail or be corrupted}%{if participants drop out}
                       & \good{Participants guaranteed correctness}\\
Self-service Execution & \good{Beacon is the source data, so can only predict that}
                       & N/A
                       & \good{Only source can fail}%{doesn't this mean single point of failure?}
                       & \baad{All users must agree on randomness}%{isn't that the point of the beacon?}
\\
Verifiable             & N/A                                                              & N/A                              & N/A                                    & \good{Fundamental}                        \\
Contestable            & N/A                                                              & N/A                              & \baad{Contesting may interrupt}        & \good{Challenge beacon on correctness}    \\ \bottomrule
    \end{tabularx}
    \caption{My caption}
    \label{my-label}
\end{table}

    Based on this evaluation we will later determine how specific beacon implementations affect the properties given their variations.
