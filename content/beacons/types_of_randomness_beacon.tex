\subsection{Types of Randomness Beacon}
%   Beacon types
We present some archetypes of randomness beacons derived from combinations of the above properties.
Moreover, we briefly describe the main strengths and weaknesses for each archetype.
They will later be related to approaches in the taxonomy of current randomness beacons.

\subsubsection{Autocratic Collector}\label{ssub:autocratic}
The most na√Øve implementation of a randomness beacon is an autocratic beacon, which collects input from an external private source.
This means that a single entity governs the randomness beacon with complete authority, meaning that no transparency is required.
Randomness beacons of this type are highly scalable, since scaling of the output publication is trivial.
Moreover, there is no bottleneck in collecting entropy as input, since it only relies on measuring something in the real world e.g.\ background radiation.

However, autocratic beacons are untrustworthy in nature, since the entity has total self-governing.
There is no validation present in this type, it is neither verifiable nor contestable, not even if the input entropy is published as proof.
This is because the private external input source which itself cannot be verified by users.

An example fitting this archetype is the \gls{nist} beacon~\cite{nistbeacon}.

\subsubsection{Specialized \gls{mpc}}\label{ssub:specialized_mpc}
To alleviate the need for absolute trust in the beacon operator, a beacon protocol utilizing \acrfull{mpc} can be deployed.
This eliminates the need for trust between individual participants.
A beacon of this type will source its entropy from user input during the execution of the \gls{mpc} beacon protocol.
The randomness outcome can therefore be trusted by any user to be unbiased, if and only if said user participated in the \gls{mpc} protocol.
Effectively this means that while this type does not require absolute trust it requires absolute participation --- all users wanting a trustworthy outcome must participate.

As a consequence, the availability can be severely hindered if one or multiple adversaries decides to drop out mid-execution.
Because of this, a specialized \gls{mpc} beacon is best suited for a private setting, where we can assume that participants will carry out the computation, and ban anyone who tries to corrupt the beacon.

Scaling \gls{mpc} protocols, can also be cumbersome if not outright impossible, especially in relation to a beacon, where the outcome is required to be published at a given time.

\subsubsection{Transparent Authority}\label{ssub:transparent_authority}
As a middle ground between the two previous beacon archetypes, the transparent authority beacon aims to provide both scalability, availability, and trustworthiness.
This is possible since the beacon displays transparency in both entropy sourcing and execution, i.e.\ using publicly available external or user generated input, and enabling validation of the execution and outcome.
However, the transparency of the authority behind the beacon can still be a self-announced entity --- as long as validation is possible, the execution model is irrelevant.

If the execution of the beacon protocol is to be done by a single entity, it is important to have a solid incentive for running it --- as well as an incentive for the operator to be honest.
This can be as simple as a community funded entity serving a \enquote{public good} as discussed by \citet{bunz2017proofsof}.

Because this beacon type uses publicly available or user generated input, entropy source manipulation from adversaries must be taken into account --- often resolving in a probabilistic trust assumption, where the probability of a biased outcome is negligible.

