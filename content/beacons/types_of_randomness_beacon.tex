\subsection{Archetypes of Randomness Beacon}
%   Beacon types
We present some archetypes of randomness beacons derived from beacon variations.
We briefly describe the main strengths and weaknesses for each archetype,  and they will later be used in the taxonomy of current randomness beacons.

\subsubsection{Autocratic Collector}\label{ssub:autocratic}
The most na√Øve implementation of a randomness beacon is an autocratic beacon, which collects input from an external private source.
A single entity governs the randomness beacon with complete authority, and no transparency required.
Randomness beacons of this type are highly scalable, since scaling of the output publication is trivial.
There is also no bottleneck in collecting entropy for the input, since it only relies on measuring something in the real world e.g.\ background radiation.

However, autocratic beacons are untrustworthy in nature, since the entity is completely self-governing.
There is no validation present in this type, it is neither verifiable nor contestable, not even if the input entropy is published as proof.
This is because the private external input source which itself cannot be verified by users.

An example of this archetype is the \gls{nist} beacon~\cite{nistbeacon}.
A more general example of autocratic collector beacon types can be seen in \Cref{fig:autocratic_beacon}, where the green marking depicts the components under total control of the beacon operator.
It can also be seen that the output of the private external entropy source, $I_t$, can be manipulated or even manufactured by the autocratic beacon operator; without users being able to detect it.

\begin{figure}[htb]\pgfdeclarelayer{background}
    \pgfsetlayers{background,main}
    \centering
    \footnotesize
    \begin{tikzpicture}[auto]
        \node[block] (input) {Private external\\entropy source};
        \node[block, right=1cm of input] (computation) {Computation\\$f(I_t)$};
        \node[block, right=1cm of computation] (users) {Users};
        \draw[arrow] (input) -- node (inp) {$I_t$} (computation);
        \node[above=1em of inp] {Undetectable internal manipulation of $I_t$ possible for operator};
        \draw[arrow] (computation) -- node {$R$} (users);
        \begin{pgfonlayer}{background}
            \node[block] (beacon) [container, fit={(input) (computation)}] {};
        \end{pgfonlayer}
    \end{tikzpicture}
    \caption{An autocratic collector beacon}\label{fig:autocratic_beacon}
\end{figure}


\subsubsection{Specialized \gls{mpc}}\label{ssub:specialized_mpc}
To alleviate the need for absolute trust in the beacon operator, a beacon protocol utilizing \acrfull{mpc} \cite{goldreich1998secure} can be deployed. \gls{mpc} is a way for a group of users to secretly input to some and perform computation, without learning each others inputs. For a beacon this would mean users inputting secret inputs, that would then be used to generate randomness.   
This eliminates the need for trust between individual participants.
A beacon of this type will source its entropy from user input during the execution of the \gls{mpc} beacon protocol.
The randomness outcome can therefore be trusted by any user to be unbiased, if and only if said user participated in the \gls{mpc} protocol.
Effectively this means that while this type does not require absolute trust it requires absolute participation --- all users wanting a trustworthy outcome must participate, or trust at least one of the participants.

As a consequence, the availability can be severely hindered if one or multiple adversaries decide to drop out mid-execution.
Because of this, a specialized \gls{mpc} beacon is best suited for a private setting, where we can assume that participants will carry out the computation, and ban anyone who tries to corrupt the beacon.

Scaling \gls{mpc} protocols, can also be difficult if not outright impossible, especially in relation to a beacon, where the outcome is required to be published at regular intervals.

An example of a specialized \gls{mpc} beacon protocol can be seen in \Vref{fig:mpc_beacon}, where the green marking covers the scope of the sequential \gls{mpc} between participants.
In the figure, $i_{u,t}$ denotes a single user's $u$ input, and $R'$ the output of a given iteration.
The sequential computation then performs $f'(I'_t)$, where $I'_t$ is the outcome of prevoius iteration and the current user's input, i.e.\ $R' \times i_{u,t} = I'_t$.
In the last step of the sequential \gls{mpc} protocol the final beacon outcome $R$ is published to all users.

\begin{figure}[htb]\pgfdeclarelayer{background}
    \pgfsetlayers{background,main}
    \centering
    \footnotesize
    \begin{tikzpicture}[auto]
        \node[block] (input) {Each user's input};
        \node[block, text width=9em, right=1cm of input] (computation) {Partial computation\\$f'(I'_t)$};
        \node[block, right=1.5cm of computation] (users) {Users};
        \draw[arrow] (input) -- node (inp) {$i_{u,t}$} (computation);
        \node[above=1em of inp] {Done sequentially by all participants};
        \draw[arrow] (computation) -- node {$R$} (users);
        \draw[arrow] (computation.east) to [out=-10, in=-90, looseness=2] node (rprime) {$R'$} (computation.south);
        \begin{pgfonlayer}{background}
            \node[block] (beacon) [container, fit={(input) (computation) (rprime)}] {};
        \end{pgfonlayer}
    \end{tikzpicture}
    \caption{Example of a specialized \gls{mpc} beacon protocol}\label{fig:mpc_beacon}
\end{figure}


\subsubsection{Transparent Authority}\label{ssub:transparent_authority}
As a middle ground between the two previous beacon archetypes, the transparent authority beacon aims to provide scalability, availability, and trustworthiness.
This is possible since the beacon displays transparency in both entropy sourcing and execution, i.e.\ using publicly available external or user generated input, and enabling validation of the execution and outcome.
However, the authority behind the beacon can still be a self-announced entity --- as long as validation is possible, the execution model is irrelevant.

If the execution of the beacon protocol is to be done by a single entity, it is important to have a solid incentive for running it --- as well as an incentive for the operator to be honest.
This can be as simple as a community funded entity serving a \enquote{public good} as discussed by \citet{bunz2017proofsof}.

Because this beacon type uses publicly available or user generated input, entropy source manipulation from adversaries must be taken into account --- often resolving in a probabilistic trust assumption, where the probability of a biased outcome is negligible.

In \Vref{fig:transparent_beacon} we show an example of a beacon of transparent authority, where the green markings indicate where the authority has power to affect the outcome.
As can be seen on the figure, the authority has to commit the input $I_t$, at a given time $t$.
This input is verifiable, and therefore the outcome will also be verifiable, due to the nature of a transparent authority.


\begin{figure}[htb]\pgfdeclarelayer{background}
    \pgfsetlayers{background,main}
    \centering
    \footnotesize
    \begin{tikzpicture}[auto]
        \node[block] (input) {Verifiable input};
        \node[block, right=1cm of input] (computation) {Computation\\$f(I_t)$};
        \node[block, right=1cm of computation] (users) {Users};
        \draw[arrow] (input) -- node (inp) {$I_t$} (computation);
        \draw[arrow] (computation) -- node {$R$} (users);
        \node[above=1em of computation] {Authority commits to input $I_t$ at time $t$};
        \begin{pgfonlayer}{background}
            \node[block] (beacon) [container, fit={(computation)}] {};
        \end{pgfonlayer}
    \end{tikzpicture}
    \caption{Example of a transparent authority beacon}\label{fig:transparent_beacon}
\end{figure}

