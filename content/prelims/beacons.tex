% \subsection{Randomness Beacon Technology}
% A randomness beacon is a method, possibly involving a trusted party, of generating uniform random strings that are unknown before the moment of their generation~\cite{andrychowicz2014distributed}
% \stefan{what does "are not know" mean: cannot be known (due to entropy) or impossible to compute (due to NP-hardness) or? Whenever you are not concrete, then at least say "informally, ..."}
% \stefan{is that all? should it not have additional properties like "verifiability"?}.
% Beacons are hard to construct, and often rely on trusted third parties like the \acrfull{nist}~\cite{nistbeacon} or Random.org\footnote{\url{https://www.random.org}}.
% If the beacon wants to avoid relying on third parties it can use publicly available data.
% An example of such data could be blocks in the Bitcoin blockchain, which has been proposed before~\cite{bonneau2015bitcoin} \stefan{i think this sentence should go in intro. here in the background section you should rather focus on defining requirements}.

% A randomness beacon is constructed by, at regular intervals, applying a deterministic computation on some input (entropy), as depicted in~\cref{fig:beacon}. The output of the computation is a random value that has the property of being \emph{unpredictable} \todo{Define what this means}.

% \begin{figure}[htb]
% \centering
% \begin{tikzpicture}[auto]
%     \node[block] (input) {Entropy\\(input)};
%     \node[block, right=1cm of input] (computation) {Computation};
%     \node[block, right=1cm of computation] (output) {Randomness (output)};
%     \path[arrow, swap] (input) -- (computation);
%     \path[arrow, swap] (computation) -- (output);
% \end{tikzpicture}
% \caption{The broad structure of a randomness beacon. A deterministic computation performed on some input entropy leads to an output of randomness. This process should be repeated at regular intervals. \stefan{explain these components and why they are needed. Why not directly use the entropy? what properties should the computation have? what properties the randomness at the outbut? }}\label{fig:beacon}
% \end{figure}

% \todo{Define more properties: Availability, Integrity}


% Randomness beacon technology
\section{Randomness Beacons}
%   What is a beacon?
In the context of this paper, we define a beacon as an entity, which publishes some data, at a regular known interval.
This constant stream of data is the opposite of \emph{on-demand}, which does not have a set interval, and must be triggered to output data.
A \emph{randomness} beacon is therefore defined as some entity publishing \emph{random} data, at a regular known interval.
Formally, let $B: f(I_t) \rightarrow R$, where $B$ is a beacon, $I_t$ is the input at time $t$ and $f$ is some computation, then $R$ is the random outcome.
For $B$ to be a beacon it is then run at every $t_\Delta$ time interval, with new input $I_t$.
The function $f$ can be an extractor function, which takes some input $x$ and outputs $y$, trading length of output for a higher level of entropy.
Extractor functions and their properties are further explained by \citet{bonneau2015bitcoin}.\msmnote{maybe expand on extractor functions in some Entropy section?}

The definition of a \emph{randomness beacon} does not specify any properties about, interaction, security, nor execution of the beacon and its protocol.
These properties rely on the setting and requirements of a given beacon.
However, all randomness beacon approaches must address the following specifications.

\subsection{Specifications of a Randomness Beacon}
%   Beacon specifications
When dealing with specifications of a randomness beacon, we focus on two main perspectives, namely \emph{security objectives}, and \emph{trust assumptions}.
These describe what a randomness beacon must take into account regarding security and attacks, and what assumptions can be made about the trustworthiness of said beacon.
Security and trust are two sides of the same coin, which means that the approach a given beacons takes to handling the security objectives will influence and define the trust assumptions about it;
but also that a beacon aiming for a given set of trust assumptions, must implement specific security measures.
%       Security objectives
\subsubsection{Security Objectives}\label{ssub:security_objectives}
For randomness beacons there exists two prevalent concepts when it comes to security objectives: \emph{availability} and \emph{integrity}.
Each term embodies multiple attacks and requirements for fulfillment, however, different randomness beacon approaches assigns different priorities to these.

\begin{description}

    \item[Availability:]
        Attacks on the availability essentially prevent a set of users from being able to gain access to a given randomness beacon.
        This can be both their ability to contribute with input, or discover the output.
        In scenarios where the beacon is driven by a single entity, attacking the availability can also mean preventing the beacon from collecting input or publishing the outcome, thereby effectively denying service for all potential users.
        Besides attacks, bugs in the implementation or network failures can result in degraded availability;
        generally these vulnerabilities are present in the same scenarios as direct attacks.
        Therefore a randomness beacon prioritizing availability, can choose to focus on robustness, redundancy, and failover, to mitigate failures and attacks on availability.

        Examples of concrete attacks on the availability of a randomness beacon are:
        \acrfull{dos} where an attacker overwhelms the beacon with e.g.\ input, thereby making any other user unable to supply entropy as input. A \gls{dos} attack could also be on the availability of the source of input itself; eclipse attacks where an attacker eclipses a part of the network, thus only making the beacon unavailable to some select users.

    \item[Integrity:]
        The integrity of a randomness beacon, determines whether or not a given user should trust the outcome and to what degree.
        Attacking the integrity is therefore, any attack which compromises the outcome of a randomness beacon.
        This can mean manipulating the input/entropy to the beacon, but also compromising the entire computation and outcome;
        as beacons can be seen as entities and not a particular actor, one might imagine a scenario where an attacker imposes themselves as the beacon.
        As with availability, the integrity can also be influenced by bugs in the implementation.
        Moreover, if the implementation is closed sources / proprietary, the beacon loses transparency and the integrity will be questionable at best.

        Attacks on the integrity could be: successfully supplying valid input, which is able to bias the outcome, e.g.\ last draw attacks, where an adversary supplies the last input and therefore potentially is able to choose some input beneficial to them;
        if the operator of the beacon is malicious, they might be able to generate a seemingly fair and random outcome by corrupting the computation of the beacon.

        The integrity also relies on the beacon being unpredictable, i.e.\ no adversary should be able to predict the outcome before it is too late to manipulate it.
        Finally, integrity also embodies the fact that the outcome should be unbiased and uniformly distributed.

\end{description}

%       Trust assumptions
\subsubsection{Trust Assumptions}\label{ssub:trust_assumptions}
As stated previously, the prioritization of the aforementioned security objectives establishes the assumptions one can make about the trustworthiness of a randomness beacon.
Moreover, the trust assumptions also depend on the interaction with, and execution of the beacon, as well as the source of entropy of the beacon.
The following trust assumptions are from a users point of view, unless otherwise stated.
A user is anyone with a stake in the outcome of the beacon, both through direct use, but also indirect/inferred usage.
\begin{description}

    \item [Guaranteed Entropy Level:]
        Assumptions about the level of entropy in the outcome, relies on the entropy of the input and the properties of the computation which generates the outcome, e.g.\ an extractor function.
        Firstly, this means that the functions used to compute the outcome should be publicly available, such that anyone will be able to verify that the level of entropy is not degraded.
        Secondly, the user must be able to reason about the entropy level of the input.

    \item [Verifiability:]
        For a beacon to display verifiability, its user must be able to verify correct execution of the beacon protocol.
        This includes being able to check input sources to the randomness beacon;
        consequently the input to the beacon must be available for it to be verifiable, unless the beacon is able to produce a proof, which then allows users to verify with zero-knowledge\msmnote{this could be interesting to expand upon, to allow for anonymized beacon interaction}.

        The most straight forward process of verification for randomness beacons, is the ability for anyone to run the same computation on the same input.
        However, in some cases this may be impractical or the input should remain secret; thereby calling for another approach to proofing validity of the outcome.

    \item [Input Reasoning:]
        Being able to reason about the input is somewhat coupled to the two previous trust assumptions.
        But assuming that we can trust the entropy level of the input, what assumptions are users able to make about the bias of the input.
        This mainly relates to beacons where the input is supplied by users, i.e.\ users which does not necessarily trust each other.

        A given user might not need to worry about the input, even if everybody else is colluding against said user.
        This is true in a scenario where said user is able to contribute with their own input, and the beacons computation is fair
        --- i.e.\ no one user's input affects the outcome differently.

\end{description}

%   Settings for beacons:
\subsection{Settings for Randomness Beacons}
%       Private
%       Public
%       Trustable?
%       In relation to specifications

%   Beacon types
\subsection{Types of Randomness Beacon}
%       Specialised protocol with MPC / homomorpgic encryption
%       Closed source entropy authority
%       External consensus driven, blockchain!

